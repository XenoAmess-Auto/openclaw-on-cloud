# OpenClaw 图片上传方案原型文档

## 1. 项目架构概述

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              OpenClaw on Cloud                               │
├─────────────────────────────────────────────────────────────────────────────┤
│  ┌──────────────┐         ┌──────────────┐         ┌─────────────────────┐  │
│  │   Frontend   │◄───────►│   Backend    │◄───────►│  OpenClaw Gateway   │  │
│  │  (Vue3+TS)   │   HTTP  │(Spring Boot) │  WS/HTTP│    (AI Service)     │  │
│  └──────┬───────┘         └──────┬───────┘         └─────────────────────┘  │
│         │                        │                                           │
│         │  1. Upload file        │  2. Store file                            │
│         │───────────────────────►│  3. Return URL                            │
│         │                        │                                           │
│         │  4. Send msg with      │  5. Process message                       │
│         │     attachment URL     │     + attachments                         │
│         │───────────────────────►│  6. Forward to OpenClaw                   │
│         │                        │     (convert to data URL)                 │
│         │                        │──────────────────────────────────────────►│
│         │                        │                                           │
│         │  7. Stream response    │  8. AI response                           │
│         │◄───────────────────────│◄──────────────────────────────────────────│
└─────────┴────────────────────────┴───────────────────────────────────────────┘
```

### 1.2 技术栈

| 层级 | 技术 | 版本 |
|------|------|------|
| 前端 | Vue 3 + TypeScript + Pinia | ^3.4 |
| 前端构建 | Vite | ^5.0 |
| 后端 | Spring Boot | 3.2.x |
| 后端语言 | Java | 25 |
| 数据库 | MongoDB | 7.x |
| 实时通信 | WebSocket | - |
| AI 服务 | OpenClaw Gateway | - |

## 2. 现有图片上传功能分析

### 2.1 已实现的功能

1. **前端文件选择和上传**
   - 点击上传按钮选择文件
   - 支持拖拽粘贴图片
   - 支持图片预览

2. **后端文件存储**
   - 本地文件系统存储
   - 文件类型验证 (image/*, pdf, txt)
   - 文件大小限制 (默认10MB)

3. **消息附件传输**
   - WebSocket 传输带附件的消息
   - 附件元数据存储在 MongoDB

4. **AI 多模态支持**
   - OpenClaw 接收图片并分析
   - 图片压缩优化 (最大1MB)
   - 支持 JPEG/PNG/GIF/WebP

### 2.2 核心代码文件位置

```
backend/src/main/java/com/ooc/
├── controller/FileController.java          # 文件上传 REST API
├── service/FileStorageService.java         # 文件存储业务逻辑
├── config/FileProperties.java              # 文件配置属性
├── config/WebConfig.java                   # 静态资源映射
├── websocket/ChatWebSocketHandler.java     # WebSocket 消息处理
├── openclaw/OpenClawPluginService.java     # AI 服务集成
└── entity/ChatRoom.java                    # 消息实体(含附件)

frontend/src/
├── api/file.ts                             # 文件上传 API 封装
├── stores/chat.ts                          # 聊天状态管理
├── views/HomeView.vue                      # 聊天界面(含上传UI)
└── types/index.ts                          # TypeScript 类型定义
```

## 3. 图片上传详细流程

### 3.1 前端上传流程

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  选择文件   │────►│  预览显示   │────►│  上传文件   │────►│  获取URL    │
│ (File Input)│     │(ObjectURL)  │     │(FormData)   │     │(API Response)│
└─────────────┘     └─────────────┘     └─────────────┘     └──────┬──────┘
                                                                   │
                    ┌─────────────┐     ┌─────────────┐           │
                    │  渲染消息   │◄────│ WebSocket   │◄──────────┘
                    │ (含图片)    │     │   发送      │
                    └─────────────┘     └─────────────┘
```

### 3.2 代码示例

**前端文件上传 API (`frontend/src/api/file.ts`)：**

```typescript
import apiClient from './client'
import type { FileUploadResponse } from '@/types'

export const fileApi = {
  upload: (file: File) => {
    const formData = new FormData()
    formData.append('file', file)
    return apiClient.post<FileUploadResponse>('/files/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    })
  }
}
```

**前端处理文件选择 (`HomeView.vue`)：**

```typescript
// 文件选择处理
async function handleFileSelect(event: Event) {
  const target = event.target as HTMLInputElement
  const files = target.files
  if (!files || files.length === 0) return

  isUploading.value = true
  try {
    for (const file of Array.from(files)) {
      // 上传到服务器
      const response = await fileApi.upload(file)
      // 使用服务器返回的 URL
      const previewUrl = response.data.url
      attachments.value.push({
        ...response.data,
        previewUrl
      })
    }
  } catch (err: any) {
    console.error('File upload failed:', err)
    alert('文件上传失败: ' + (err.response?.data?.message || err.message))
  } finally {
    isUploading.value = false
  }
}

// 粘贴图片处理
async function handlePaste(event: ClipboardEvent) {
  const items = event.clipboardData?.items
  if (!items) return

  const imageFiles: File[] = []
  for (let i = 0; i < items.length; i++) {
    const item = items[i]
    if (item.type.startsWith('image/')) {
      const file = item.getAsFile()
      if (file) imageFiles.push(file)
    }
  }

  if (imageFiles.length === 0) return
  event.preventDefault()
  isUploading.value = true

  try {
    for (const file of imageFiles) {
      const response = await fileApi.upload(file)
      attachments.value.push({
        ...response.data,
        previewUrl: response.data.url
      })
    }
  } catch (err: any) {
    alert('图片上传失败: ' + (err.response?.data?.message || err.message))
  } finally {
    isUploading.value = false
  }
}
```

**发送带附件的消息 (`stores/chat.ts`)：**

```typescript
function sendMessage(content: string, attachments: Attachment[] = []) {
  if (ws.value && ws.value.readyState === WebSocket.OPEN) {
    const payload: any = { type: 'message', content }
    
    if (attachments.length > 0) {
      payload.attachments = attachments.map(att => ({
        type: 'image',
        mimeType: att.mimeType,
        url: att.dataUrl  // 服务器返回的 URL，如 /uploads/uuid.jpg
      })).filter(att => att.url)
    }
    
    ws.value.send(JSON.stringify(payload))
  }
}
```

### 3.3 后端处理流程

**文件上传控制器 (`FileController.java`)：**

```java
@Slf4j
@RestController
@RequestMapping("/api/files")
@RequiredArgsConstructor
public class FileController {

    private final FileStorageService fileStorageService;

    @PostMapping("/upload")
    public ResponseEntity<FileInfo> uploadFile(@RequestParam("file") MultipartFile file) {
        log.info("Uploading file: {}, size: {}", file.getOriginalFilename(), file.getSize());
        FileInfo fileInfo = fileStorageService.store(file);
        log.info("File uploaded successfully: {}", fileInfo.getUrl());
        return ResponseEntity.ok(fileInfo);
    }
}
```

**文件存储服务 (`FileStorageService.java`)：**

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class FileStorageService {

    private final FileProperties fileProperties;

    @PostConstruct
    public void init() {
        try {
            Path uploadPath = Paths.get(fileProperties.getUploadDir());
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
                log.info("Created upload directory: {}", uploadPath.toAbsolutePath());
            }
        } catch (IOException e) {
            log.error("Could not create upload directory", e);
        }
    }

    public FileInfo store(MultipartFile file) {
        // 验证文件类型
        String contentType = file.getContentType();
        if (contentType == null || !Arrays.asList(fileProperties.getAllowedTypes()).contains(contentType)) {
            throw new RuntimeException("不支持的文件类型: " + contentType);
        }

        // 验证文件大小
        long maxSizeBytes = fileProperties.getMaxSize() * 1024 * 1024;
        if (file.getSize() > maxSizeBytes) {
            throw new RuntimeException("文件大小超过限制: " + fileProperties.getMaxSize() + "MB");
        }

        try {
            // 生成唯一文件名
            String originalFilename = file.getOriginalFilename();
            String extension = "";
            if (originalFilename != null && originalFilename.contains(".")) {
                extension = originalFilename.substring(originalFilename.lastIndexOf("."));
            }
            String filename = UUID.randomUUID() + extension;

            // 保存文件
            Path targetLocation = Paths.get(fileProperties.getUploadDir()).resolve(filename);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);

            // 获取绝对路径供 OpenClaw 读取
            Path absolutePath = targetLocation.toAbsolutePath().normalize();

            // 确定文件类型
            FileType type = determineFileType(contentType);

            return FileInfo.builder()
                    .filename(filename)
                    .originalName(originalFilename)
                    .url(fileProperties.getUrlPrefix() + "/" + filename)  // /uploads/uuid.jpg
                    .localPath(absolutePath.toString())
                    .type(type)
                    .contentType(contentType)
                    .size(file.getSize())
                    .build();

        } catch (IOException e) {
            log.error("Failed to store file", e);
            throw new RuntimeException("文件存储失败", e);
        }
    }

    private FileType determineFileType(String contentType) {
        if (contentType == null) return FileType.FILE;
        if (contentType.startsWith("image/")) return FileType.IMAGE;
        if (contentType.equals("application/pdf")) return FileType.PDF;
        if (contentType.equals("text/plain")) return FileType.TEXT;
        return FileType.FILE;
    }

    public enum FileType { IMAGE, PDF, TEXT, FILE }

    @lombok.Data
    @lombok.Builder
    public static class FileInfo {
        private String filename;
        private String originalName;
        private String url;           // 访问URL，如 /uploads/uuid.jpg
        private String localPath;     // 本地绝对路径
        private FileType type;
        private String contentType;
        private long size;
    }
}
```

**静态资源配置 (`WebConfig.java`)：**

```java
@Configuration
@RequiredArgsConstructor
public class WebConfig implements WebMvcConfigurer {

    private final FileProperties fileProperties;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        Path uploadPath = Paths.get(fileProperties.getUploadDir()).toAbsolutePath().normalize();
        registry.addResourceHandler(fileProperties.getUrlPrefix() + "/**")
                .addResourceLocations("file:" + uploadPath.toString() + "/");
    }
}
```

## 4. AI 多模态集成方案

### 4.1 OpenClaw 图片处理流程

```
┌─────────────────┐
│  用户发送消息   │
│  (含图片URL)    │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ WebSocket Handler│
│  解析附件URL     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐     ┌─────────────────┐
│ OpenClawPlugin  │────►│  读取本地文件   │
│    Service      │     │  (/uploads/xxx) │
└────────┬────────┘     └─────────────────┘
         │
         ▼
┌─────────────────┐     ┌─────────────────┐
│  压缩图片       │────►│  转为 Data URL  │
│ (最大1MB)       │     │ (Base64编码)    │
└────────┬────────┘     └─────────────────┘
         │
         ▼
┌─────────────────┐
│  构建多模态消息  │
│  (text + image) │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ 发送到OpenClaw  │
│  Gateway API    │
└─────────────────┘
```

### 4.2 多模态消息构建代码

**OpenClawPluginService.java 关键代码：**

```java
/**
 * 发送消息到 OpenClaw 并获取回复（支持附件）
 */
public Mono<OpenClawResponse> sendMessage(String sessionId, String message, 
        List<ChatWebSocketHandler.Attachment> attachments, String userId, String userName) {
    
    // 构建消息内容块（支持多模态）
    List<Map<String, Object>> contentBlocks = new ArrayList<>();
    
    // 添加文本内容块
    if (processedMessage != null && !processedMessage.isEmpty()) {
        Map<String, Object> textBlock = new HashMap<>();
        textBlock.put("type", "text");
        textBlock.put("text", userName + ": " + processedMessage);
        contentBlocks.add(textBlock);
    }
    
    // 添加图片附件内容块
    if (attachments != null && !attachments.isEmpty()) {
        for (ChatWebSocketHandler.Attachment att : attachments) {
            if ("image".equalsIgnoreCase(att.getType())) {
                String imageDataUrl = null;
                
                // 优先使用 URL（可能是 /uploads/xxx.png 或完整 URL）
                if (att.getUrl() != null && !att.getUrl().isEmpty()) {
                    String url = att.getUrl();
                    if (url.startsWith("/uploads/")) {
                        // 相对路径，读取文件并转为 base64
                        imageDataUrl = readFileToDataUrl(url, att.getMimeType());
                    } else if (url.contains("/uploads/")) {
                        // 完整路径，提取文件名并读取
                        imageDataUrl = readFileToDataUrlFromFullPath(url, att.getMimeType());
                    } else if (url.startsWith("data:")) {
                        // 已经是 data URL，直接使用
                        imageDataUrl = url;
                    }
                } else if (att.getContent() != null && !att.getContent().isEmpty()) {
                    // 使用 base64 内容构造 data URL
                    imageDataUrl = "data:" + att.getMimeType() + ";base64," + att.getContent();
                }
                
                if (imageDataUrl != null) {
                    Map<String, Object> imageBlock = new HashMap<>();
                    imageBlock.put("type", "image_url");
                    Map<String, String> imageUrl = new HashMap<>();
                    imageUrl.put("url", imageDataUrl);
                    imageBlock.put("image_url", imageUrl);
                    contentBlocks.add(imageBlock);
                }
            }
        }
    }
    
    // 构建 OpenAI 格式请求
    List<Map<String, Object>> messages = new ArrayList<>();
    
    // 添加系统消息
    Map<String, Object> systemMsg = new HashMap<>();
    systemMsg.put("role", "system");
    systemMsg.put("content", "You are OpenClaw, a helpful AI assistant...");
    messages.add(systemMsg);
    
    // 添加用户消息（多模态格式）
    Map<String, Object> userMsg = new HashMap<>();
    userMsg.put("role", "user");
    userMsg.put("content", contentBlocks);  // 这里 content 是数组，支持多模态
    messages.add(userMsg);

    Map<String, Object> request = new HashMap<>();
    request.put("model", "openclaw:main");
    request.put("messages", messages);
    request.put("user", sessionId);
    request.put("tool_choice", "auto");

    return getWebClient().post()
            .uri("/v1/chat/completions")
            .header(HttpHeaders.AUTHORIZATION, "Bearer " + properties.getApiKey())
            .bodyValue(request)
            .retrieve()
            .bodyToMono(ChatCompletionResponse.class)
            .map(response -> new OpenClawResponse(
                    UUID.randomUUID().toString(),
                    response.choices().get(0).message().content(),
                    Instant.now(),
                    true
            ));
}
```

**图片压缩代码：**

```java
/**
 * 压缩图片以限制文件大小
 */
private byte[] compressImageIfNeeded(byte[] imageBytes, String mimeType) {
    try {
        // 如果已经小于1MB，不需要压缩
        if (imageBytes.length <= MAX_IMAGE_SIZE_MB * 1024 * 1024) {
            return null;
        }
        
        log.info("Image size {} bytes exceeds limit, compressing...", imageBytes.length);
        
        // 读取图片
        BufferedImage originalImage = ImageIO.read(new ByteArrayInputStream(imageBytes));
        if (originalImage == null) {
            log.warn("Could not read image for compression");
            return null;
        }
        
        int originalWidth = originalImage.getWidth();
        int originalHeight = originalImage.getHeight();
        
        // 计算缩放比例
        double scale = Math.min(
            (double) MAX_IMAGE_WIDTH / originalWidth,
            (double) MAX_IMAGE_HEIGHT / originalHeight
        );
        
        int newWidth = (int) (originalWidth * scale);
        int newHeight = (int) (originalHeight * scale);
        
        // 创建缩放后的图片
        Image scaledImage = originalImage.getScaledInstance(newWidth, newHeight, Image.SCALE_SMOOTH);
        BufferedImage resizedImage = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d = resizedImage.createGraphics();
        g2d.drawImage(scaledImage, 0, 0, null);
        g2d.dispose();
        
        // 使用JPEG格式压缩，调整质量
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        float quality = JPEG_QUALITY; // 0.85f
        
        while (quality >= 0.3f) {
            outputStream.reset();
            
            ImageWriter writer = ImageIO.getImageWritersByFormatName("jpg").next();
            ImageWriteParam param = writer.getDefaultWriteParam();
            param.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
            param.setCompressionQuality(quality);
            
            try (ImageOutputStream ios = ImageIO.createImageOutputStream(outputStream)) {
                writer.setOutput(ios);
                writer.write(null, new IIOImage(resizedImage, null, null), param);
            }
            writer.dispose();
            
            byte[] result = outputStream.toByteArray();
            
            if (result.length <= MAX_IMAGE_SIZE_MB * 1024 * 1024) {
                log.info("Compressed image to {} bytes with quality {}", result.length, quality);
                break;
            }
            
            quality -= 0.1f;
        }
        
        return outputStream.toByteArray();
        
    } catch (Exception e) {
        log.error("Failed to compress image", e);
        return null;
    }
}
```

## 5. 数据模型设计

### 5.1 消息附件实体

**后端 (`ChatRoom.java`)：**

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public static class Attachment {
    @JsonProperty("id")
    private String id;

    @JsonProperty("url")
    private String url;           // 访问URL: /uploads/uuid.jpg

    @JsonProperty("name")
    private String name;          // 原始文件名

    @JsonProperty("type")
    private String type;          // IMAGE, PDF, TEXT, FILE

    @JsonProperty("contentType")
    private String contentType;   // MIME类型: image/jpeg

    @JsonProperty("size")
    private long size;            // 文件大小(字节)
}
```

**前端 (`types/index.ts`)：**

```typescript
export interface Attachment {
  id: string
  url: string
  name: string
  type: 'IMAGE' | 'PDF' | 'TEXT' | 'FILE' | 'image' | 'pdf' | 'text' | 'file'
  contentType: string
  size: number
}

export interface Message {
  id: string
  senderId: string
  senderName: string
  content: string
  timestamp: string
  // ... 其他字段
  attachments?: Attachment[]
}

export interface FileUploadResponse {
  filename: string
  originalName: string
  url: string
  type: 'IMAGE' | 'PDF' | 'TEXT' | 'FILE'
  contentType: string
  size: number
}
```

## 6. 配置文件

### 6.1 后端配置 (`application.yml`)

```yaml
file:
  upload-dir: ./uploads                    # 上传目录
  allowed-types:                           # 允许的文件类型
    - image/jpeg
    - image/png
    - image/gif
    - image/webp
    - application/pdf
    - text/plain
  max-size: 10                             # 最大文件大小(MB)
  url-prefix: /uploads                     # URL前缀

openclaw:
  gateway-url: ws://localhost:8080         # OpenClaw Gateway地址
  api-key: ${OPENCLAW_API_KEY}             # API密钥
  session-timeout-ms: 300000               # 会话超时时间(5分钟)
```

### 6.2 前端配置

```typescript
// api/client.ts
import axios from 'axios'

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL || '/api',
  timeout: 30000,
})

export default apiClient
```

## 7. 关键技术要点

### 7.1 图片压缩策略

1. **尺寸限制**: 最大 1024x1024 像素
2. **大小限制**: 压缩后最大 1MB
3. **压缩格式**: 统一转为 JPEG
4. **质量调整**: 从 0.85 开始递减，直到满足大小限制

### 7.2 安全性考虑

1. **文件类型验证**: 只允许白名单中的 MIME 类型
2. **文件大小限制**: 防止大文件攻击
3. **XSS 防护**: 使用 DOMPurify 清理消息内容
4. **路径安全**: 使用 UUID 作为文件名，防止路径遍历

### 7.3 性能优化

1. **懒加载**: 图片使用 `loading="lazy"`
2. **预览优化**: 上传前显示本地预览，上传后切换为服务器 URL
3. **WebSocket 流式**: AI 响应使用流式传输，减少等待时间
4. **图片压缩**: 发送到 AI 前自动压缩，减少传输时间

## 8. 扩展建议

### 8.1 云存储集成 (可选)

```java
// 阿里云 OSS 示例
@Service
public class OssStorageService implements FileStorageService {
    
    @Autowired
    private OSS ossClient;
    
    public FileInfo store(MultipartFile file) {
        String filename = UUID.randomUUID().toString();
        ossClient.putObject("bucket-name", filename, file.getInputStream());
        
        return FileInfo.builder()
                .filename(filename)
                .url(ossClient.generatePresignedUrl("bucket-name", filename, expiration))
                .build();
    }
}
```

### 8.2 图片处理服务 (可选)

- 使用 thumbnailator 生成缩略图
- 使用 CDN 加速图片访问
- 支持 WebP 格式自动转换

### 8.3 图片审核 (可选)

- 集成阿里云/腾讯云内容审核 API
- 在上传前进行敏感内容检测

## 9. 部署注意事项

1. **上传目录权限**: 确保应用有读写 `./uploads` 目录的权限
2. **磁盘空间**: 监控上传目录磁盘使用情况
3. **备份策略**: 定期备份上传的文件
4. **Nginx 配置**: 如果前端和后端分离部署，需要配置反向代理

```nginx
location /uploads/ {
    proxy_pass http://backend:8081/uploads/;
}

location /api/ {
    proxy_pass http://backend:8081/api/;
}

location /ws/ {
    proxy_pass http://backend:8081/ws/;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
}
```

## 10. 总结

本方案实现了完整的图片上传和处理流程：

1. ✅ 前端支持文件选择、粘贴、拖拽上传
2. ✅ 后端本地存储，支持文件类型和大小验证
3. ✅ WebSocket 实时传输带附件的消息
4. ✅ AI 多模态支持，图片自动压缩后发送到 OpenClaw
5. ✅ 流式响应，实时显示 AI 处理结果

整个流程安全可靠，性能良好，可以支撑生产环境使用。
